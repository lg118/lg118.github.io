<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Scala隐式转换的问题分析</title>
      <link href="/2019/12/24/Scala%E4%B8%AD%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/24/Scala%E4%B8%AD%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Scala隐式转换的问题分析"><a href="#Scala隐式转换的问题分析" class="headerlink" title="Scala隐式转换的问题分析"></a>Scala隐式转换的问题分析</h1><h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>首先来看一个需求：<strong>将String类型的数字赋值给Int类型的变量。</strong></p><p>也就是这样：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> num:<span class="type">Int</span>=<span class="string">"20"</span></span><br></pre></td></tr></table></figure><p>要想实现这样的效果，小伙伴们应该都能想到使用<code>隐式方法</code>这个技能。许多小伙伴一鸡冻就撸出了如下的代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>):<span class="type">Int</span>= &#123;</span><br><span class="line">      str.toInt</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong><em>友情提示：</em></strong>隐式转换的代码要定义在object中哦~~~</p><p>定义了如上的隐式方法后，接下来我们来使用一下该隐式方法。接下来来一段完整代码尝尝：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> num:<span class="type">Int</span> = <span class="string">"20"</span></span><br><span class="line">    println(num)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义的隐式方法</span></span><br><span class="line"><span class="comment">    *    该方法的功能是将String转成Int</span></span><br><span class="line"><span class="comment">    * @param str  需要转换的字符串</span></span><br><span class="line"><span class="comment">    * @return 返回 Int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>):<span class="type">Int</span>= &#123;</span><br><span class="line">    str.toInt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码撸完，感觉还不错，接着我们运行以上代码：哐当，出错啦。。。。</p><p>控制台输出以下错误信息：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Error</span>:(<span class="number">17</span>, <span class="number">5</span>) <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found   : str<span class="class">.<span class="keyword">type</span> (<span class="params">with underlying type <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"> <span class="title">required</span></span>: ?&#123;<span class="function"><span class="keyword">def</span> <span class="title">toInt</span></span>: ?&#125;</span><br><span class="line"><span class="type">Note</span> that <span class="keyword">implicit</span> conversions are not applicable because they are ambiguous:</span><br><span class="line"> both method augmentString in <span class="class"><span class="keyword">object</span> <span class="title">Predef</span> <span class="title">of</span> <span class="title">type</span> (<span class="params">x: <span class="type">String</span></span>)<span class="title">scala</span>.<span class="title">collection</span>.<span class="title">immutable</span>.<span class="title">StringOps</span></span></span><br><span class="line"><span class="class"> <span class="title">and</span> <span class="title">method</span> <span class="title">strToInt</span> <span class="title">in</span> <span class="title">object</span> <span class="title">TestDemo</span> <span class="title">of</span> <span class="title">type</span> (<span class="params">str: <span class="type">String</span></span>)<span class="title">Int</span></span></span><br><span class="line"><span class="class"> <span class="title">are</span> <span class="title">possible</span> <span class="title">conversion</span> <span class="title">functions</span> <span class="title">from</span> <span class="title">str</span>.<span class="title">type</span> <span class="title">to</span> <span class="title">?</span></span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">toInt</span></span>: ?&#125;</span><br><span class="line">    str.toInt</span><br><span class="line"><span class="type">Error</span>:(<span class="number">17</span>, <span class="number">9</span>) value toInt is not a member of <span class="type">String</span></span><br><span class="line">    str.toInt</span><br></pre></td></tr></table></figure><p>大伙看错误信息中有个关键的单词<code>ambiguous(模糊不清的，模棱两可的)</code>，以上错误信息的大致意思是说：</p><blockquote><p>隐式转换在这里不适用了，因为隐式转换出现了模糊不清的情况，这里有两个方法<br>一个在object Predef中有一个<strong>augmentString</strong>方法将x:String转成scala.collection.immutable.StringOps，<br>另一个在object TestDemo中有<strong>strToInt</strong>方法将str: String转成了Int<br>以上两个方法都可以将str: String转成了Int，所以隐式转换出现了模糊不清的情况</p></blockquote><p>看完后估计有的小伙伴还是一头雾水，这到底是说的啥，这到底是为什么？？好，那接下来我们就看看其中的究竟。</p><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><h3 id="分析String相关的源码"><a href="#分析String相关的源码" class="headerlink" title="分析String相关的源码"></a>分析String相关的源码</h3><p>首先我们来看一段代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> str:<span class="type">String</span> = <span class="string">"20"</span></span><br><span class="line">   <span class="keyword">val</span> i = str.toInt</span><br><span class="line">   println(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码的正确编译运行，输出结果是Int类型的<code>20</code>。</p><p>接下来我们按住键盘上的Ctrl，鼠标点击String查看String类型，发现在object Predef中有这么一段代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">String</span>        </span>= java.lang.<span class="type">String</span></span><br></pre></td></tr></table></figure><p>通过这段代码我们知道，Scala中的String其实是使用了java中的String。好了，那我们回顾以下java中的String有toInt()方法吗，熟悉Java的肯定立马就能回答：没有。对的，就是没有！！</p><p>String中没有toInt()方法，但是这里的<code>str</code>却可以使用<code>toInt()</code>，那说明<code>str.toInt</code>这里发生了隐式转换。没错，这里的str由String转换成了StringOps。这么转换的呢，我们上源码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">augmentString</span></span>(x: <span class="type">String</span>): <span class="type">StringOps</span> = <span class="keyword">new</span> <span class="type">StringOps</span>(x)</span><br></pre></td></tr></table></figure><p>在object Perdef中有一个隐式方法<code>augmentString</code>将String转换成了StringOps。接着我们再来看看StringOps的源码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOps</span>(<span class="params">override val repr: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> <span class="keyword">with</span> <span class="title">StringLike</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">thisCollection</span></span>: <span class="type">WrappedString</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">WrappedString</span>(repr)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">toCollection</span></span>(repr: <span class="type">String</span>): <span class="type">WrappedString</span> = </span><br><span class="line">  <span class="keyword">new</span> <span class="type">WrappedString</span>(repr)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Creates a string builder buffer as builder for this class */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">newBuilder</span> </span>= <span class="type">StringBuilder</span>.newBuilder</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(index: <span class="type">Int</span>): <span class="type">Char</span> = repr charAt index</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">slice</span></span>(from: <span class="type">Int</span>, until: <span class="type">Int</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="keyword">if</span> (from &lt; <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> from</span><br><span class="line">    <span class="keyword">if</span> (until &lt;= start || start &gt;= repr.length)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> end = <span class="keyword">if</span> (until &gt; length) length <span class="keyword">else</span> until</span><br><span class="line">    repr.substring(start, end)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= repr</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">length</span> </span>= repr.length</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">seq</span> </span>= <span class="keyword">new</span> <span class="type">WrappedString</span>(repr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在StringOps中没有直接发现toInt()方法，不要慌，仔细看看<code>StringOps</code>继承了<code>StringLike</code>，接着我们看看<code>StringLike</code>源码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">StringLike</span>[+<span class="type">Repr</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">scala</span>.<span class="title">collection</span>.<span class="title">IndexedSeqOptimized</span>[<span class="type">Char</span>, <span class="type">Repr</span>] <span class="keyword">with</span> <span class="title">Ordered</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line"> <span class="comment">//省略代码................</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toInt</span></span>: <span class="type">Int</span>         = java.lang.<span class="type">Integer</span>.parseInt(toString)</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @throws java.lang.NumberFormatException  - If the string does not contain a parsable long.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toLong</span></span>: <span class="type">Long</span>       = java.lang.<span class="type">Long</span>.parseLong(toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于在StringLike中找到了toInt，因为<code>StringOps</code>继承了<code>StringLike</code>，所以<code>StringOps</code>也就有了toInt()。</p><p>再看刚才的隐式方法：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">augmentString</span></span>(x: <span class="type">String</span>): <span class="type">StringOps</span> = <span class="keyword">new</span> <span class="type">StringOps</span>(x)</span><br></pre></td></tr></table></figure><p>隐式方法<code>augmentString</code>将String转换成了<code>StringOps</code>，所以：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> str:<span class="type">String</span> = <span class="string">"20"</span></span><br><span class="line">   <span class="keyword">val</span> i = str.toInt <span class="comment">// 底层代码实现：augmentString(str).toInt</span></span><br><span class="line">   println(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>好了，通过以上代码分析，我们知道<code>StringOps</code>中存在<code>toInt</code>方法，所以通过隐式转换将str转成StringOps后就可以调用toInt了。</p><h3 id="分析Int相关的源码"><a href="#分析Int相关的源码" class="headerlink" title="分析Int相关的源码"></a>分析Int相关的源码</h3><p>接下来，我们继续分析Int类的源码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Int</span> <span class="title">private</span> <span class="keyword">extends</span> <span class="title">AnyVal</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略代码</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toInt</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toLong</span></span>: <span class="type">Long</span></span><br><span class="line">  <span class="comment">//省略代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过查看Int的源码发现在Int中也存在一个<code>toInt</code>的方法，那么现在如果也存在一个将String转成Int的隐式方法，那么，String也能调用<code>toInt</code>了。分析到这里，我们渐渐的感觉到发现冲突产生的地方了，好的，我们马上来看看我们写的隐式方法的代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义的隐式方法</span></span><br><span class="line"><span class="comment">    *    该方法的功能是将String转成Int</span></span><br><span class="line"><span class="comment">    * @param str  需要转换的字符串</span></span><br><span class="line"><span class="comment">    * @return 返回 Int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>):<span class="type">Int</span>= &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 通过分析我们知道StringOps和Int都有toInt方法，所以</span></span><br><span class="line"><span class="comment">      * str.toInt在这里有两个隐式函数都可以进行转换</span></span><br><span class="line"><span class="comment">      * 1、使用scala.Predef 中的</span></span><br><span class="line"><span class="comment">      *       implicit def augmentString(x: String): StringOps = new StringOps(x)</span></span><br><span class="line"><span class="comment">      *   所以str.toInt 就等价于  augmentString(str).toInt</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 2、使用自己定义这个隐式方法(递归调用)</span></span><br><span class="line"><span class="comment">      *      augmentString 就等价于 strToInt(str).toInt</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *  好了，我们知道隐式转换只能匹配一个，不能有多个，</span></span><br><span class="line"><span class="comment">      *  而这里str.toInt找到两个隐式转换都可以实现，所以出现了之前“模棱两可”的错误信息</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    str.toInt</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>既然分析清楚了出现错误的原因，接下来我们就根据原因来看看如何解决吧。</p><p><strong>解决方法的本质就是不要让toInt隐式转换的时候找到多个隐式方法出现“模棱两可”。</strong></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>使用<code>Integer.parseInt(str)</code>替换<code>str.toInt</code>。完整代码代码如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">Int</span> = <span class="string">"20"</span></span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>):<span class="type">Int</span>= &#123;</span><br><span class="line">    <span class="type">Integer</span>.parseInt(str)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Integer.parseInt(str)</code>替换<code>str.toInt</code>，没有使用<code>str.toInt</code>了，隐式转换自然就就没有了。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用<code>new StringOps(str).toInt</code>替换<code>str.toInt</code>。完整代码代码如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">Int</span> = <span class="string">"20"</span></span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>):<span class="type">Int</span>= &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StringOps</span>(str).toInt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>new StringOps(str).toInt</code>替换<code>str.toInt</code>。这里使用<code>new StringOps(str)</code>显式调用了<code>toInt</code>，所以也没有隐式转换了。</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>将自己定义的隐式方法<code>implicit def strToInt(str:String):Int</code>的返回值省略，该方法就不能被递归调用了，那这时候<code>str.toInt</code>就只有<code>implicit def augmentString(x: String): StringOps</code>这一个隐式转换方法了，也解决了两个隐式方法的冲突问题。完整代码如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">Int</span> = <span class="string">"20"</span>  <span class="comment">// error</span></span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>) = &#123;</span><br><span class="line">    str.toInt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码第四行<code>val str:Int = &quot;20&quot;</code>编译错误，错误信息如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Error</span>:(<span class="number">8</span>, <span class="number">19</span>) <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found   : <span class="type">String</span>(<span class="string">"20"</span>)</span><br><span class="line"> required: <span class="type">Int</span></span><br><span class="line"> <span class="type">Note</span>: <span class="keyword">implicit</span> method strToInt is not applicable here because it comes after the application point and it lacks an explicit result <span class="class"><span class="keyword">type</span></span></span><br><span class="line"><span class="class">    <span class="title">val</span> <span class="title">str</span></span>:<span class="type">Int</span> = <span class="string">"20"</span></span><br></pre></td></tr></table></figure><p>出现该错误的原因是：</p><blockquote><p>隐式方法没有显式给出返回类型，必须位于应用点之前</p></blockquote><p>所以正确代码如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(str:<span class="type">String</span>) = &#123;</span><br><span class="line">    str.toInt</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">Int</span> = <span class="string">"20"</span></span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里我们的问题分析及解决方案就结束了，希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle安装和卸载</title>
      <link href="/2018/03/10/Oracle%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/"/>
      <url>/2018/03/10/Oracle%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle安装和卸载"><a href="#Oracle安装和卸载" class="headerlink" title="Oracle安装和卸载"></a>Oracle安装和卸载</h1><h2 id="Oracle版本说明"><a href="#Oracle版本说明" class="headerlink" title="Oracle版本说明"></a>Oracle版本说明</h2><p>Oracle 9i<br>Oracle 10g<br>Oracle 11g<br>Oracle 12c</p><p>i：i 代表 Internet。8i 版本开启对 Internet 的支持。所以，在版本号之后，添加了标识 i。<br>g：g 代表 Grid 网格。10g 加入了网格计算的功能，因此版本号之后的标识使用了字母g。<br>c：c 代表云(cloud)计算设计。12c 版本表示对云计算的支持。</p><h2 id="Oracle安装"><a href="#Oracle安装" class="headerlink" title="Oracle安装"></a>Oracle安装</h2><ol><li><p>两个.zip文件下载完成后，解压两个压缩包到同一目录（默认是“database”）。</p></li><li><p>双击解压目录下的setup.exe安装oracle（注意：安装文件路径不要使用特殊字符、空格、汉字等）。执行安装程序，会出现一个命令行窗口。</p></li><li><p>命令行窗口小时候，如果出现以下界面：</p><p><img alt="0.jpg" data-src="https://i.loli.net/2019/12/16/pRQrNP8syHDjvBS.jpg" class="lazyload"></p><p>出现这个问题是因为配置文件中配置了对应的系统，所以需要添加自己对应的系统。<br>首先打开解压后的database文件夹，找到stage文件夹，再找到cvu文件夹，进去后打开cvu_prereq.xml文件，在该文件中的CERTIFIED_SYSTEMS标签中添加如下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">OPERATING_SYSTEM</span> <span class="attr">RELEASE</span>=<span class="string">"6.2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">VERSION</span> <span class="attr">VALUE</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ARCHITECTURE</span> <span class="attr">VALUE</span>=<span class="string">"64-bit"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NAME</span> <span class="attr">VALUE</span>=<span class="string">"Windows 10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ENV_VAR_LIST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ENV_VAR</span> <span class="attr">NAME</span>=<span class="string">"PATH"</span> <span class="attr">MAX_LENGTH</span>=<span class="string">"1023"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ENV_VAR_LIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OPERATING_SYSTEM</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改完成后保存退出，再次点击setup.exe运行就不会出现这个错误了。</p></li><li><p>开始安装<br><img alt="1.jpg" data-src="https://i.loli.net/2019/12/16/jza9GdfpF6BknMu.jpg" class="lazyload"></p><p><img alt="2.jpg" data-src="https://i.loli.net/2019/12/16/KOXfQHAoj5iRZsm.jpg" class="lazyload"></p></li></ol><p>​        <img alt="3.jpg" data-src="https://i.loli.net/2019/12/16/bMKkYPWxU69hHDn.jpg" class="lazyload"></p><p><img alt="4.jpg" data-src="https://i.loli.net/2019/12/16/i5CFNlHKczEAQRg.jpg" class="lazyload"></p><p><img alt="4-1.jpg" data-src="https://i.loli.net/2019/12/16/NKAMr5Z3ByLgVzD.jpg" class="lazyload"></p><p><img alt="4-2.jpg" data-src="https://i.loli.net/2019/12/16/CfMtenBqkVXU4vS.jpg" class="lazyload"></p><p><img alt="5.jpg" data-src="https://i.loli.net/2019/12/16/EFTkZA6sQaw4mqj.jpg" class="lazyload"></p><p><img alt="6.jpg" data-src="https://i.loli.net/2019/12/16/cvMHVqlZw9uf5rg.jpg" class="lazyload"></p><p><img alt="7.jpg" data-src="https://i.loli.net/2019/12/16/YBj39618g52PFGp.jpg" class="lazyload"></p><p><img alt="7-1.jpg" data-src="https://i.loli.net/2019/12/16/wqvpmD3tkcoBx6S.jpg" class="lazyload"></p><p><img alt="7-2.jpg" data-src="https://i.loli.net/2019/12/16/IjraQJVFX5HZuSk.jpg" class="lazyload"></p><p><img alt="7-3.jpg" data-src="https://i.loli.net/2019/12/16/1MQrmJ4n6Wy2D9d.jpg" class="lazyload"></p><p><img alt="7-4.jpg" data-src="https://i.loli.net/2019/12/16/RMyVxrPzDUNwQJE.jpg" class="lazyload"></p><p><img alt="8.jpg" data-src="https://i.loli.net/2019/12/16/NaidTWpsxj5PLol.jpg" class="lazyload"></p><h2 id="Oracle卸载"><a href="#Oracle卸载" class="headerlink" title="Oracle卸载"></a>Oracle卸载</h2><ol><li><p>停止使用 Oracle 的服务</p><p>进入计算机管理，在服务中，找到 oracle 开头的所有服务，右击选择停止。</p></li><li><p>运行卸载 Oracle 数据库程</p><p>在开始菜单中找到 Oracle 安装产品，点击运行 Oracle 自带的卸载程序 Universal Installer工具卸载。</p></li><li><p>删除使用 Oracle 的服务</p><p>开始菜单中，找到 Universal Installer，运行 Oracle Universal Installer，单击卸载产品，在产品清单窗口中，单击全部展开，除了 OraDb11g_home1 外，勾选其他项目，单击删除，根据软件提示单击下一步最终完成卸载。</p></li><li><p>删除注册表中 Oracle 相关项</p><ul><li><p>在 命 令 窗 口 ， 输 入 regedit ， 打 开 注 册 表 ， 依 次 展 开<code>HKEY_LOCAL_MACHINE\SOFTWARE</code>，找到 oracle删除</p></li><li><p>依次展开 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</code> 中，删除所有oracle 开头的项</p></li><li><p>依 次 展 开<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application</code>，删除<br>所有 oracle 开头的项</p></li><li>扩展删除（以下不是必须的注册表删除项），如果安装不成功也可以把这些删除了<ul><li>在 <code>HKEY_CLASSES_ROOT</code>，删除以 Ora、Oracle、Orcl 或 EnumOra 为前缀的键</li><li>删 除<br><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MenuOrder\StartMenu\Programs</code> 中所有以 oracle 开头的键</li><li>删 除 <code>HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI</code> 中 除 <code>Microsoft ODBC for Oracle</code>注册表键以外的所有含有 Oracle 的键</li></ul></li></ul></li><li><p>删除 Oracle 环境变量</p><p>右键点击我的电脑—&gt;属性—&gt;高级—&gt;环境变量,删除环境变量 ORACLE_HOME、TNS_ADMIN 等环境变量，删除 PATH 中等环境变量有关 Oracle 的设定的路径信息</p></li><li><p>删除“开始”菜单中 Oracle 目录</p><p>打开资源管理器，在地址栏中输入“%userprofile%\「开始」菜单\程序”回车，删除安装的 Oracle 目录。然后再到地址栏中输入“%allusersprofile%\「开始」菜单\程序”回车，删除安装的 Oracle 目录</p></li><li><p>重新启动计算机</p></li><li><p>删除 Program Files\Oracle 目录</p><p>如果 Program Files\Oracle 目录存在，则删除 Program Files\Oracle 目录。</p></li><li><p>删除 Oracle 安装目录</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala的数据类型</title>
      <link href="/2018/03/01/Scala%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/01/Scala%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学过Java我们知道Java中的数据类型分为：基本数据类型和引用数据类型。</p><p>Java中的基本数据类型不能当作对象使用，所以Java也不能称之为纯面向对象的语言。</p><p>而今天我们介绍的Scala却是一个纯面向对象的语言，真的很纯哦。。。。</p><p>那么，既然Scala是一个纯面向对象的语言，所以其中的数据类型应该也和对象有关联，接下来我们就来看看Scala中的数据类型。</p><h2 id="Scala的数据类型"><a href="#Scala的数据类型" class="headerlink" title="Scala的数据类型"></a>Scala的数据类型</h2><p>在Scala中，所有的值（包括数值和函数）都有类型，下图展示了Scala中数据类型层次结构：</p><p><img alt="data.jpg" data-src="https://i.loli.net/2019/12/13/9tvcKjRgbFym8Qo.jpg" class="lazyload"></p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><ul><li><p>Any是Scala中所有数据类型的超类型，也叫做<strong><em>顶级类型</em></strong>。</p></li><li><p>Any定义了一些通用的方法：equals、hashCode、toString和getClass等。</p></li><li><p>Any有两个直接的子类：</p><ul><li><p><strong>AnyVal</strong></p></li><li><p><strong>AnyRef</strong></p></li></ul></li></ul><h4 id="AnyVal"><a href="#AnyVal" class="headerlink" title="AnyVal"></a>AnyVal</h4><ul><li><p>AnyVal表示<strong>值类型</strong></p></li><li><p>AnyVal包括9个子类型：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Byte</span><br><span class="line">Short</span><br><span class="line">Int</span><br><span class="line">Long</span><br><span class="line">Char</span><br><span class="line">Float</span><br><span class="line">Double</span><br><span class="line">Boolean</span><br><span class="line">Unit</span><br></pre></td></tr></table></figure><p>其中1-7又被称为<strong><em>数值类型</em></strong>（numeric value types）;</p><p>​        8-9又被称为<strong><em>非数值类型</em></strong>（non-numeric value types）</p></li></ul><p>  <strong>当然，AnyVal的9个子类型还有一种分组方式：</strong></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- The &apos;&apos;subrange types&apos;&apos; are [[scala.Byte]], [[scala.Short]], and [[scala.Char]].</span><br><span class="line"></span><br><span class="line">- The &apos;&apos;integer types&apos;&apos; include the subrange types as well as [[scala.Int]] and [[scala.Long]].</span><br><span class="line"></span><br><span class="line">- The &apos;&apos;floating point types&apos;&apos; are [[scala.Float]] and [[scala.Double]].</span><br></pre></td></tr></table></figure><h5 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h5><p>  ​    Unit是不带任何意义的值类型，它仅有一个实例可以像这样声明：()。</p><p>  ​    因为Scala中所有的函数必须有返回，所以说有时候Unit也是有用的返回类型。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>  AnyVal的9种类型 就是java中8种基本数据类型 + Unit类型。不过Scala中的Byte、Int等不是基本数据类型，而是可以做对象使用的。比如：</p>  <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> num:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">println(num.toString)<span class="comment">//num可以调用方法</span></span><br></pre></td></tr></table></figure><h4 id="AnyRef"><a href="#AnyRef" class="headerlink" title="AnyRef"></a>AnyRef</h4><ul><li><p>AnyRef代表引用类型。</p></li><li><p>所有非值类型都被定义为引用类型。</p></li><li><p>在Scala中，每个用户自定义的类型都是AnyRef的子类型。</p></li><li><p>如果Scala被应用在Java的运行环境中，AnyRef相当于java.lang.Object。</p></li></ul><h5 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h5><ul><li><p>Nothing是所有类型的子类型，也称为<strong><em>底部类型</em></strong></p></li><li><p>没有一个值是Nothing类型的。它的用途之一是给出非正常终止的信号，如抛出异常、程序退出或者一个无限循环（可以理解为它是一个不对值进行定义的表达式的类型，或者是一个不能正常返回的方法）。</p><p><strong><em>比如：</em></strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法是用来抛出异常的，不需要返回具体的结果。所以返回值定义成Nothing即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">break</span></span>(): <span class="type">Nothing</span> = &#123; <span class="keyword">throw</span> breakException &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><ul><li><p>Null是所有引用类型的子类型（即AnyRef的任意子类型）。</p></li><li><p>它有一个单例值由关键字null所定义。</p></li><li><p>Null主要是使得Scala满足和其他JVM语言的互操作性，但是几乎不应该在Scala代码中使用。</p><p><strong><em>比如：</em></strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在类型定义的属性，初始化的时候就不推荐使用null,而是用_</span></span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span>=_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
